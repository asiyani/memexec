// +build windows

package main

import (
	"bufio"
	"bytes"
	"embed"
	"fmt"
	"io"
	"log"
	"os"
	"syscall"
	"unsafe"

	"github.com/Binject/go-donut/donut"
	"golang.org/x/sys/windows"
)

//go:embed embed/hello.exe
var f embed.FS

func main() {

	exebytes, err := f.ReadFile("embed/hello.exe")
	if err != nil {
		log.Fatalf("unable to read file %v", err)
	}

	config := donut.DonutConfig{
		Arch:       donut.X84,
		Type:       donut.DONUT_MODULE_EXE,
		InstType:   donut.DONUT_INSTANCE_PIC,
		Entropy:    donut.DONUT_ENTROPY_DEFAULT, // use symmetric encryption
		Thread:     1,                           // run entrypoint as a thread
		OEP:        0,
		Runtime:    "v4.0.30319",
		Compress:   1, // disable
		Format:     1, // output format of loader: raw/Binary
		Bypass:     3, // AMSI/WLDP bypass 1=skip, 2=abort on fail, 3=continue on fail.
		ExitOpt:    1, // 1=exit thread, 2=exit process
		Domain:     "helloworld",
		Parameters: "--name memexec --sleep 10",
	}

	shellcode, err := donut.ShellcodeFromBytes(bytes.NewBuffer(exebytes), &config)
	if err != nil {
		log.Fatalf("unable to generate shellcode %v", err)
	}

	err = executeShellcode(shellcode.Bytes())
	if err != nil {
		log.Fatalf("Error executing shellcode %s", err)
	}

	fmt.Printf("<--main func closed-->")
}

func executeShellcode(shellcode []byte) error {
	size := len(shellcode)

	// allocate memory for shellcode
	addr, err := windows.VirtualAlloc(0, uintptr(size), windows.MEM_COMMIT|windows.MEM_RESERVE, windows.PAGE_READWRITE)
	if err != nil {
		return fmt.Errorf("VirtualAlloc failed %s", err)
	}

	defer func() {
		err := windows.VirtualFree(addr, 0, windows.MEM_RELEASE)
		if err != nil {
			fmt.Printf("VirtualFree failed %s", err)
		}
	}()

	// copy shellcode to new memory location
	for i := uintptr(0); i < uintptr(size); i++ {
		*(*uint8)(unsafe.Pointer(addr + i)) = shellcode[i]
	}

	// convert memory to execute only
	var oldprotect uint32
	err = windows.VirtualProtect(addr, uintptr(size), windows.PAGE_EXECUTE, &oldprotect)
	if err != nil {
		return fmt.Errorf("VirtualProtect failed %s", err)
	}

	// To capture stdout/stdErr of syscall
	stdOutR, stdOutW, err := os.Pipe()
	if err != nil {
		fmt.Printf("unable to create pipe %s\n", err)
	}
	stdErrR, stdErrW, err := os.Pipe()
	if err != nil {
		fmt.Printf("unable to create pipe %s\n", err)
	}
	defer func() {
		stdOutW.Close()
		stdOutR.Close()
		stdErrR.Close()
	}()

	err = redirectStdoutAndErr(stdOutW, stdErrW)
	if err != nil {
		fmt.Printf("unable to redirect std %s", err)
	}

	// start read syscall stdout in diff go routine
	go func() {
		scanner := bufio.NewScanner(stdOutR)
		for scanner.Scan() {
			fmt.Printf("from_syscall:%s \n", scanner.Text())
		}
		if err := scanner.Err(); err != nil {
			fmt.Printf("error reading syscall stdout: %s", err)
		}
	}()

	_, _, errSyscall := syscall.Syscall(addr, 0, 0, 0, 0)
	// syscall generates 'The parameter is incorrect' 0x57 error
	// but shellcode does execute properly
	if errSyscall != 0 && errSyscall != 0x57 {
		return fmt.Errorf("error executing shellcode syscall: %s", errSyscall.Error())
	}
	// close stdErrW write to read from stdErrR
	stdErrW.Close()

	// read any error message generated by shellcode
	errMsg, err := io.ReadAll(stdErrR)
	if err != nil {
		return err
	}
	if len(errMsg) > 0 {
		return fmt.Errorf("syscall errors: %s", errMsg)
	}

	return nil
}

func redirectStdoutAndErr(stdOutW *os.File, stdErrW *os.File) error {
	err := windows.SetStdHandle(windows.STD_OUTPUT_HANDLE, windows.Handle(stdOutW.Fd()))
	if err != nil {
		return fmt.Errorf("Failed to redirect stdout to file: %w", err)
	}
	err = windows.SetStdHandle(windows.STD_ERROR_HANDLE, windows.Handle(stdErrW.Fd()))
	if err != nil {
		return fmt.Errorf("Failed to redirect stderr to file: %w", err)
	}
	return nil
}
